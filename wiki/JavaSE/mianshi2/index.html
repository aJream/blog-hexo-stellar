<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 5.4.2">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://fastly.jsdelivr.net'>
  <link rel="preconnect" href="https://fastly.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>JavaSE：Java面试基础题 - aJream</title>

  
    <meta name="description" content="Java面试基础  面向对象和面向过程的区别  面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix 等一般采用面向过程开发。但是面向过程没有面向对象易维护、易复用、易扩展。 面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦">
<meta property="og:type" content="website">
<meta property="og:title" content="Java面试基础题">
<meta property="og:url" content="https://ajream-n.netlify.app/wiki/JavaSE/mianshi2/">
<meta property="og:site_name" content="aJream">
<meta property="og:description" content="Java面试基础  面向对象和面向过程的区别  面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix 等一般采用面向过程开发。但是面向过程没有面向对象易维护、易复用、易扩展。 面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE2.png">
<meta property="article:published_time" content="2022-09-29T12:49:53.261Z">
<meta property="article:modified_time" content="2022-09-29T12:49:53.261Z">
<meta property="article:author" content="aJream">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"onload="renderMathInElement(document.body);"></script>
  


  
    
      <script defer src="https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
    
      <link rel="stylesheet" href="https://npm.elemecdn.com/font-awesome/css/font-awesome.min.css"/ media="defer" onload="this.media='all'">
    
      <link rel="shortcut icon" href="/images/favicon.png">
    
      <link rel="stylesheet" type="text/css" href="/css/custom/return_top_bilibili.css" />
    
      <link rel="stylesheet" type="text/css" href="/css/custom/code_copy.css" />
    
      <link rel="stylesheet" type="text/css" href="/css/custom/code_unfold.css" />
    
      <link rel="stylesheet" type="text/css" href="/css/custom/custom.css" />
    
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    


<header class="header">

<div class="logo-wrap wiki"><a style="filter: grayscale(100%)" class="wiki-home cap" href="/wiki"><svg aria-hidden="true" viewBox="0 0 16 16" width="1rem" height="1rem" fill="currentColor"><path fill-rule="evenodd" d="M7.78 12.53a.75.75 0 01-1.06 0L2.47 8.28a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L4.81 7h7.44a.75.75 0 010 1.5H4.81l2.97 2.97a.75.75 0 010 1.06z"></path></svg>所有专栏</a><a class="title" href="/wiki/JavaSE/javase_1/"><div class="main">☕JavaSE学习笔记</div><div class="sub cap">Java基础(含少量javaEE)</div></a></div>
</header>

<div class="widgets">

<div class="widget-wrap multi" id="toc"><div class="widget-header cap dis-select"><span class="name">基础学习</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_1/"><span class="toc-text">Java(1) 类与对象</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_2/"><span class="toc-text">Java(2.1) 类和对象的属性初始化</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_3/"><span class="toc-text">Java(2.2) 访问修饰符</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_4/"><span class="toc-text">Java(3.1) 数据类型</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_5/"><span class="toc-text">Java(3.2) 数组</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_6/"><span class="toc-text">Java(4) 变量</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_7/"><span class="toc-text">Java(5) 操作符</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_8/"><span class="toc-text">Java(6) 输入语句</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_9/"><span class="toc-text">Java(7) 条件语句</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_10/"><span class="toc-text">Java(8) 循环语句</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_11/"><span class="toc-text">Java(9) package包</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_12/"><span class="toc-text">Java(10) 装箱与拆箱</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_13/"><span class="toc-text">Java(11) 数字与字符串相互转换</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_14/"><span class="toc-text">Java(12) 字符串操作</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_15/"><span class="toc-text">Java(13) 日期与日历</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_16/"><span class="toc-text">Java(14) 接口与继承</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_17/"><span class="toc-text">Java(15) 异常处理</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_18/"><span class="toc-text">Java(16) 文件IO</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_19/"><span class="toc-text">Java(17) 集合框架</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_20/"><span class="toc-text">Java(17) 容器</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_21/"><span class="toc-text">Java(18) 泛型</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_22/"><span class="toc-text">Java(19) 多线程系列</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_23/"><span class="toc-text">Java(20) 反射机制</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_24/"><span class="toc-text">Java(21) 注解</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/javase_25/"><span class="toc-text">Java(22) Lambda表达式</span></a></div></div><div class="widget-header cap dis-select"><span class="name">面试八股</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/mianshi1/"><span class="toc-text">java垃圾回收算法</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/JavaSE/mianshi2/"><span class="toc-text">Java面试基础题</span></a><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text"> 面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9"><span class="toc-text"> Java语言有哪些特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm-jdk-jre"><span class="toc-text"> jvm、jdk、jre</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%92%8Cc%E5%AF%B9%E6%AF%94"><span class="toc-text"> Java和C++对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text"> 字符型常量和字符串常量的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8constructor%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%ABoverride"><span class="toc-text"> 构造器Constructor是否可被override</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text"> 重载和重写的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85-%E7%BB%A7%E6%89%BF-%E5%A4%9A%E6%80%81"><span class="toc-text"> Java 面向对象编程三大特性：封装 继承 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text"> 封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text"> 继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text"> 多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stringbuffer%E5%92%8Cstringbuilder"><span class="toc-text"> StringBuffer和StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-text"> 可变性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text"> 线程安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-text"> 性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-text"> 自动装箱与拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%86%85%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E6%B3%95%E7%9A%84"><span class="toc-text"> 在一个静态方法内调用一个非静态成员为什么是非法的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8java%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text"> 在Java中定义一个不做事且没有参数的构造方法的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text"> 接口和抽象类的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-text"> 对象实体与对象引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text"> 类的构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="toc-text"> 静态方法与实例方法区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89vs%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89"><span class="toc-text"> 对象相等vs引用相等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B7%E4%B8%8Eequals%E6%96%B9%E6%B3%95"><span class="toc-text"> &#x3D;&#x3D;号与equals方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashcode-%E4%B8%8E-equals"><span class="toc-text"> hashCode 与 equals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-text"> Java值传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B"><span class="toc-text"> 线程、进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0"><span class="toc-text"> 简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-text"> 线程生命周期的几种基本状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text"> final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text"> Java异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text"> 获取用键盘输入常用的两种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E4%B8%AD-io-%E6%B5%81%E5%88%86%E7%B1%BB"><span class="toc-text"> Java 中 IO 流分类</span></a></li></ol></div></div><div class="widget-header cap dis-select"><span class="name">GUI开发</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/awt/"><span class="toc-text">AWT基本操作与使用</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/swing/"><span class="toc-text">Swing基本操作与使用</span></a></div></div><div class="widget-header cap dis-select"><span class="name">其它</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/servlet1/"><span class="toc-text">1-Servlet</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/servlet2/"><span class="toc-text">2-Servlet生命周期</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/servlet3/"><span class="toc-text">3-ServletRequest对象</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/servlet4/"><span class="toc-text">4-请求转发</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/tomcat1/"><span class="toc-text">Tomcat基础</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/tomcat2/"><span class="toc-text">IDEA配置Tomcat</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/JavaSE/http/"><span class="toc-text">HTTP协议</span></a></div></div></div>



<div class="widget-wrap" id="related"><div class="widget-header cap dis-select"><span class="name">更多Java</span></div><div class="widget-body fs14"><a class="more-item wiki" href="/wiki/ssm/spring/spring_1/">🚀SSM学习笔记<div class="excerpt">SSM框架是Spring MVC ，Spring和Mybatis框架的整合，是标准的MVC模式，将整个系统划分为View层，Controller层，Service层，DAO层四层，使用Spring MVC负责请求的转发和视图管理，Spring实现业务对象管理，Mybatis作为数据对象的持久化引擎。</div></a><a class="more-item wiki" href="/wiki/mysql/mysql_1/">🍬MySQL学习笔记<div class="excerpt">MySQL是一种关系型数据库管理系统，采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型和大型网站的开发都选择 MySQL 作为网站数据库。</div></a></div></div>
</div>


    </aside>
    <div class='l_main'>
      

      

  
  
<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/JavaSE/javase_1/">☕JavaSE学习笔记</a></div><div id="post-meta">更新于&nbsp;<time datetime="2022-09-29T12:49:53.261Z">2022-09-29</time></div></div>

  <article class='content md wiki'>
  <h1 class="article-title"><span>Java面试基础题</span></h1>
  <h1 id="java面试基础"><a class="markdownIt-Anchor" href="#java面试基础"></a> Java面试基础</h1>
<h2 id="面向对象和面向过程的区别"><a class="markdownIt-Anchor" href="#面向对象和面向过程的区别"></a> 面向对象和面向过程的区别</h2>
<ul>
<li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。<strong>但是</strong>面向过程没有面向对象易维护、易复用、易扩展。</li>
<li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li>
</ul>
<h2 id="java语言有哪些特点"><a class="markdownIt-Anchor" href="#java语言有哪些特点"></a> Java语言有哪些特点</h2>
<ol>
<li>面向对象（封装，继承，多态）；</li>
<li>跨平台性（ Java 虚拟机实现平台无关性）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存</li>
</ol>
<h2 id="jvm-jdk-jre"><a class="markdownIt-Anchor" href="#jvm-jdk-jre"></a> jvm、jdk、jre</h2>
<ul>
<li>
<p>JVM是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>
</li>
<li>
<p>JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
</li>
<li>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
</li>
</ul>
<h2 id="java和c对比"><a class="markdownIt-Anchor" href="#java和c对比"></a> Java和C++对比</h2>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
</ul>
<h2 id="字符型常量和字符串常量的区别"><a class="markdownIt-Anchor" href="#字符型常量和字符串常量的区别"></a> 字符型常量和字符串常量的区别</h2>
<ol>
<li>形式上：字符常量是<strong>单引号</strong>引起的一个字符; 字符串常量是<strong>双引号</strong>引起的若干个字符</li>
<li>含义上：字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</li>
</ol>
<h2 id="构造器constructor是否可被override"><a class="markdownIt-Anchor" href="#构造器constructor是否可被override"></a> 构造器Constructor是否可被override</h2>
<p>Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h2 id="重载和重写的区别"><a class="markdownIt-Anchor" href="#重载和重写的区别"></a> 重载和重写的区别</h2>
<p>重载：同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写：当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
<h2 id="java-面向对象编程三大特性封装-继承-多态"><a class="markdownIt-Anchor" href="#java-面向对象编程三大特性封装-继承-多态"></a> Java 面向对象编程三大特性：封装 继承 多态</h2>
<h3 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h3>
<blockquote>
<ol>
<li>属性私有化</li>
<li>提供方法来访问私有属性</li>
</ol>
</blockquote>
<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<h3 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h3>
<p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<h2 id="stringbuffer和stringbuilder"><a class="markdownIt-Anchor" href="#stringbuffer和stringbuilder"></a> StringBuffer和StringBuilder</h2>
<p>两者的区别是什么? String 为什么是不可变的?</p>
<h3 id="可变性"><a class="markdownIt-Anchor" href="#可变性"></a> 可变性</h3>
<p>简单的来说：<code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</p>
<p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 的构造方法都是调用父类构造方法也就是 <code>AbstractStringBuilder</code> 实现的，大家可以自行查阅源码。</p>
<h3 id="线程安全性"><a class="markdownIt-Anchor" href="#线程安全性"></a> 线程安全性</h3>
<ul>
<li>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。</p>
</li>
<li>
<p><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。</p>
</li>
<li>
<p><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p>
</li>
<li>
<p><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是<strong>非</strong>线程安全的。</p>
</li>
</ul>
<h3 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h3>
<ul>
<li>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</p>
</li>
<li>
<p>而<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。</p>
</li>
<li>
<p>相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
</li>
</ul>
<blockquote>
<p>对于三者使用的总结：</p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
</blockquote>
<h2 id="自动装箱与拆箱"><a class="markdownIt-Anchor" href="#自动装箱与拆箱"></a> 自动装箱与拆箱</h2>
<ul>
<li>装箱：将基本类型用它们对应的引用类型包装起来；</li>
<li>拆箱：将包装类型转换为基本数据类型；</li>
</ul>
<h2 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a class="markdownIt-Anchor" href="#在一个静态方法内调用一个非静态成员为什么是非法的"></a> 在一个静态方法内调用一个非静态成员为什么是非法的</h2>
<p>由于静态方法可以不通过对象进行调用，因此在静态方法里：</p>
<ul>
<li>不能调用其他非静态变量</li>
<li>不可以访问非静态变量成员</li>
</ul>
<h2 id="在java中定义一个不做事且没有参数的构造方法的作用"><a class="markdownIt-Anchor" href="#在java中定义一个不做事且没有参数的构造方法的作用"></a> 在Java中定义一个不做事且没有参数的构造方法的作用</h2>
<p>Java 程序在实例化子类之前（即执行<strong>子类的构造方法</strong>之前），如果没有用 <code>super()</code>来调用父类特定的构造方法，则会<u>默认调用</u>父类中“没有参数的构造方法”。</p>
<p>若父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。</p>
<p>解决办法：在父类里加上一个不做事且没有参数的构造方法。</p>
<p>详细见：<a href="D:%5CUsers%5C74452%5CDesktop%5CJavaLearning%5CjavaSE%5C14-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BB%A7%E6%89%BF.md">super关键字</a></p>
<h2 id="接口和抽象类的区别"><a class="markdownIt-Anchor" href="#接口和抽象类的区别"></a> 接口和抽象类的区别</h2>
<ol>
<li>接口的方法默认是 <code>public</code>，所有方法在接口中不能有实现(Java 8开始接口方法可以有<strong>默认实现</strong>），而抽象类可以有非抽象的方法。</li>
<li>接口中除了 <code>static</code>、<code>final</code> 变量，不能有其他变量，而抽象类中则不一定。</li>
<li>一个类可以实现多个接口，但只能实现一个抽象类。<u>接口自己本身</u>可以通过 <u><code>extends</code></u> 关键字扩展多个接口。</li>
<li>接口方法默认修饰符是 <code>public</code>，抽象方法可以有 <code>public</code>、<code>protected</code> 和 <code>default</code> 这些修饰符（抽象方法就是为了被重写所以不能使用 <code>private</code> 关键字修饰！）。</li>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>
</ol>
<blockquote>
<p>备注：</p>
<ol>
<li>在 JDK8 中，接口也可以定义静态方法，可以直接用<u>接口名</u>调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。</li>
<li>jdk9 的接口被允许定义私有方法 。</li>
</ol>
</blockquote>
<h2 id="对象实体与对象引用"><a class="markdownIt-Anchor" href="#对象实体与对象引用"></a> 对象实体与对象引用</h2>
<ul>
<li>
<p>用new 运算符创建对象实例（对象实例在堆内存中）</p>
</li>
<li>
<p>对象引用指向对象实例（对象引用存放在栈内存中）</p>
</li>
</ul>
<p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;</p>
<p>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h2 id="类的构造方法"><a class="markdownIt-Anchor" href="#类的构造方法"></a> 类的构造方法</h2>
<p>类的构造方法主要作用是完成对类对象的初始化工作。</p>
<p>一个类没有声明构造方法也可以执行，因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h2 id="静态方法与实例方法区别"><a class="markdownIt-Anchor" href="#静态方法与实例方法区别"></a> 静态方法与实例方法区别</h2>
<ol>
<li>在外部调用静态方法时，可以使用&quot;<code>类名.方法名</code>&quot;的方式，也可以使用&quot;<code>对象名.方法名</code>&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li>
</ol>
<h2 id="对象相等vs引用相等"><a class="markdownIt-Anchor" href="#对象相等vs引用相等"></a> 对象相等vs引用相等</h2>
<p>对象的相等，指的是内存中存放的内容是否相等。</p>
<p>而引用相等，指的是他们指向的内存地址是否相等。</p>
<h2 id="号与equals方法"><a class="markdownIt-Anchor" href="#号与equals方法"></a> ==号与equals方法</h2>
<p>基本数据类型<code>==</code>比较的是值，而引用数据类型<code>==</code>比较的是内存地址</p>
<p>注意：</p>
<ol>
<li>
<p>类没有覆盖 equals() 方法时， equals() 比较的是两个对象的内存地址，相当于用 <code>==</code>号</p>
</li>
<li>
<p>String 中的 equals 方法是被重写过的，因此String 的 equals 方法比较的是对象的值</p>
</li>
<li>
<p>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</p>
</li>
</ol>
<h2 id="hashcode-与-equals"><a class="markdownIt-Anchor" href="#hashcode-与-equals"></a> hashCode 与 equals</h2>
<p>为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法：</p>
<ol>
<li>
<p>hashcode用来记录对象存放的地址（理解可能不到位），如果两个对象相等，则 hashcode 一定也是相同的。</p>
</li>
<li>
<p>两个对象相等，对两个对象分别调用 equals 方法都返回 true。</p>
</li>
<li>
<p>但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。</p>
</li>
<li>
<p>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖</p>
</li>
</ol>
<h2 id="java值传递"><a class="markdownIt-Anchor" href="#java值传递"></a> Java值传递</h2>
<p>Java 程序设计语言<u>总是采用按值调用</u>。也就是说，方法得到的是所有参数值的一个<strong>拷贝</strong>，即方法不能修改传递给它的任何参数变量的内容。</p>
<blockquote>
<p>与c/c<ins>不同，c/c</ins>提供了值传递和引用传递</p>
</blockquote>
<h2 id="线程-进程"><a class="markdownIt-Anchor" href="#线程-进程"></a> 线程、进程</h2>
<h3 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h3>
<p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单位</p>
<p>同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<hr />
<p><strong>进程</strong>是系统进行资源（ CPU 时间，内存空间，文件，输入输出设备的使用权等等）分配和调度的基本单位</p>
<h3 id="线程生命周期的几种基本状态"><a class="markdownIt-Anchor" href="#线程生命周期的几种基本状态"></a> 线程生命周期的几种基本状态</h3>
<ol>
<li>
<p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态</p>
</li>
<li>
<p>调用 <code>start()</code> 方法后线程这时候处于 <strong>READY（就绪）</strong> 状态。</p>
</li>
<li>
<p>可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
</li>
<li>
<p>线程执行 <code>wait()</code>方法之后，线程进入 **WAITING（等待）**状态</p>
</li>
<li>
<p>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。</p>
</li>
<li>
<p>线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java线程状态变迁" /></p>
<h2 id="final关键字"><a class="markdownIt-Anchor" href="#final关键字"></a> final关键字</h2>
<p>final 关键字主要用在三个地方：变量、方法、类。</p>
<ol>
<li>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li>
<li>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</li>
<li>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</li>
</ol>
<h2 id="java异常处理"><a class="markdownIt-Anchor" href="#java异常处理"></a> Java异常处理</h2>
<p>结构图：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="img" style="zoom:50%;"/>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE2.png" alt="img" style="zoom:33%;"/>
<p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<ul>
<li><code>Exception</code>：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为检查异常(必须处理) <code>Check Exception</code> 和 不检查异常(可以不处理) <code>Uncheck Exception</code>。</li>
<li><code>Error</code> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<ol>
<li>
<p>检查异常</p>
<p>除了``RuntimeException<code>及其子类以外，其他的</code>Exception`类及其子类都属于检查异常。常见的受检查异常有：</p>
<ul>
<li>IO 相关的异常</li>
<li><code>ClassNotFoundException</code></li>
<li><code>SQLException</code>……</li>
</ul>
</li>
<li>
<p>不检查异常</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：</p>
<ul>
<li><code>NullPointerException</code></li>
<li><code>NumberFormatException</code>（字符串转换为数字）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）等</li>
</ul>
</li>
</ol>
<p><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p>
<ol>
<li>在 try 或 finally 块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<blockquote>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖try语句的返回值。</p>
</blockquote>
<h2 id="获取用键盘输入常用的两种方法"><a class="markdownIt-Anchor" href="#获取用键盘输入常用的两种方法"></a> 获取用键盘输入常用的两种方法</h2>
<ol>
<li>通过 Scanner</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span>  <span class="operator">=</span> input.nextLine();</span><br><span class="line">input.close();Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过 BufferedReader</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.readLine();</span><br></pre></td></tr></table></figure>
<h2 id="java-中-io-流分类"><a class="markdownIt-Anchor" href="#java-中-io-流分类"></a> Java 中 IO 流分类</h2>
<ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流</li>
</ul>
<blockquote>
<p>Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来：</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
</blockquote>
<blockquote>
<p>为什么要有字符流？</p>
<p>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。</p>
<ul>
<li>
<p>音频文件、图片等二进制文件用字节流比较好，</p>
</li>
<li>
<p>涉及到字符文本文件使用字符流比较好</p>
</li>
</ul>
</blockquote>

  


  </article>
  
<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><a id="next" href="/wiki/JavaSE/awt/">AWT基本操作与使用<span class="note">下一篇</span></a><div class="line"></div><a id="prev" href="/wiki/JavaSE/mianshi1/">java垃圾回收算法<span class="note">上一篇</span></a></section></div>

  

  <div class='related-wrap md reveal' id="comments">
    <div class='cmt-title cap theme'>
      快来参与讨论吧
    </div>
    <div class='cmt-body valine'>
      

<div id="valine_container" class="valine_thread"><svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>

    </div>
  </div>




      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a></div><div class="sitemap-group"><span class="fs14">专栏</span><a href="/wiki/">全部</a><a href="/wiki/tags/Java/">Java</a><a href="/wiki/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a href="/wiki/tags/%E8%80%83%E7%A0%94/">考研</a></div><div class="sitemap-group"><span class="fs14">社交</span><a href="/friends/">友链</a><a href="/about/#comments">留言板</a></div><div class="sitemap-group"><span class="fs14">更多</span><a href="/about/">关于</a><a target="_blank" rel="noopener" href="https://github.com/ajream">GitHub</a></div></div><div class="text"><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="https://ajream-n.netlify.app/">@aJream</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.9.0" title="v1.9.0">Stellar</a> 主题创建。</p>
</div><div class="site-statistics"><span class="site-runtime"></span><div id="busuanzi_container_site_pv"> 访问量: <span id="busuanzi_value_site_pv"></span> 访客数: <span id="busuanzi_value_site_uv"></span></div></div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.9.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://fastly.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://fastly.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://fastly.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function getEmojiMaps() {
    function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
    }
    var emojiMaps = {};
    for (var i = 1; i <= 54; i++) {
      emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
    }
    for (var i = 1; i <= 101; i++) {
      emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
    }
    for (var i = 1; i <= 116; i++) {
      emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
    }
    for (var i = 1; i <= 125; i++) {
      emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
    }
    for (var i = 1; i <= 4; i++) {
      emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
    }
    return emojiMaps;
  }
  function load_comment(){
    if(!document.getElementById("valine_container"))return;
    stellar.loadScript('https://fastly.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@main/js/Valine.min.js', {defer:true}).then(function () {
      const el = document.getElementById("valine_container");
      var path = el.getAttribute('comment_id');
      const placeholder = "";
      if (!path) {
        path = decodeURI(window.location.pathname);
      }
      var valine = new Valine();
      valine.init(Object.assign({"js":"https://fastly.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@main/js/Valine.min.js","appId":"pzbFTXqhpBeDgCeiSD4IU3Uo-gzGzoHsz","appKey":"8t6hlt5VaX21ITVWzzNRGAWe","placeholder":null,"requiredFields":["nick","mail"],"enableQQ":true,"recordIP":false,"avatar":"robohash","pageSize":10,"lang":"zh-cn","highlight":true,"mathJax":false,"tagMeta":["博主","小伙伴","访客"],"metaPlaceholder":{"nick":"昵称/QQ号(必填)","mail":"邮箱（必填，完全保密）","link":"网址(https://)"},"master":["6783037F2DF30EAB99F9FC256157D875"],"friends":["6783037F2DF30EAB99F9FC256157D875"]}, {
        el: '#valine_container',
        path: path,
        placeholder: placeholder,
        emojiCDN: 'https://fastly.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
        emojiMaps: getEmojiMaps(),
      }));
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    console.log('DOM fully loaded and parsed');
    load_comment();
  });

</script>




<!-- inject -->

  
    <script defer src="/live2d-widget/autoload.js"></script>
  
    <script defer src="/js/custom/custom.js"></script>
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js"></script>
  
    <script defer src="/js/custom/code_unfold.js"></script>
  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  


  </div>

</body>
</html>
